module Test.Falsify.Gen.Distribution (
    oneof
  , frequency
  ) where

import Data.List.NonEmpty (NonEmpty)
import Data.List.NonEmpty qualified as NE
import Test.Falsify.Gen
import Test.Falsify.Gen.Simple
import Test.Falsify.Range (Range)
import Test.Falsify.Range qualified as Range

-- | Generate a value with one of many generators
--
-- Uniformly selects a generator and shrinks towards the first one.
oneof :: NonEmpty (Gen a) -> Gen a
oneof gens = frequency $ map (1,) $ NE.toList gens

{-------------------------------------------------------------------------------
  Tweak test data distribution
-------------------------------------------------------------------------------}

-- | Choose generator with the given frequency
--
-- For example,
--
-- > frequency [
-- >     (1, genA)
-- >   , (2, genB)
-- >   ]
--
-- will use @genA@ 1/3rd of the time, and @genB@ 2/3rds.
--
-- Shrinks towards generators earlier in the list; the generators themselves
-- are independent from each other (shrinking of @genB@ does not affect
-- shrinking of @genA@).
--
-- Precondition: there should at least one generator with non-zero frequency.
frequency :: forall a. [(Word, Gen a)] -> Gen a
frequency gens =
    case filter ((/= 0) . fst) indexedGens of
      []    -> error "frequency: no generators with non-zero frequency"
      gens' -> do
        let r :: Range Word
            r = Range.between (0, sum (map fst gens') - 1)
        (gen, genIx) <- (\i -> frequencyLookup i gens') <$> inRange r
        perturb genIx gen
  where
    -- We need to be careful: we don't want to perturb the generator by the
    -- value generated by 'inRange', because many different values could
    -- correspond to the /same/ generator. Instead, we assign each generator its
    -- own index, and use that instead.
    indexedGens :: [(Word, (Gen a, Word))]
    indexedGens = zipWith (\(f, g) i -> (f, (g, i))) gens [0..]

-- | Internal auxiliary to 'frequency'
frequencyLookup :: Word -> [(Word, x)] -> x
frequencyLookup = \i xs ->
    case go i xs of
      Just x  -> x
      Nothing ->
        error $ concat [
           "frequencyLookup: index "
         , show i
         , " out of range of "
         , show (map fst xs)
         ]
  where
    go :: Word -> [(Word, x)] -> Maybe x
    go _ []       = Nothing
    go i ((n, x):xs)
      | i < n     = Just x
      | otherwise = go (i - n) xs
